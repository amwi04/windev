## 22/07/2024

- InvalidateRect(hwnd, NULL, TRUE) is a post message function which asynchronously calls WM_PAINT
    - hwnd is the window
    - Null to all windows
    - bool for older replacements, TRUE means replace

## 23/07/2024

- UINT_PTR SetTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc)
    - hWnd is the window
    - nIDEvent is the timer id
    - uElapse is the elapsed time in milliseconds
    - lpTimerFunc is the timer function 
        - if you are not handling timer in wndproc then its required) 
        - if we are handling timer in wndproc then NULL is fine
    - once time is done then wndtimer will post messaage in wndproc 
- PlaySound() is avaliable in <mmsystem.h>
- BOOL PlaySound(LPCWSTR pszSound, HMODULE hmod, DWORD fdwSound)
    - MAKEINTRESOURCE to the the file resource
    - GetModuleHandle which module you want to handle Null means same window module
        - if we want differnt module use path of the module path
    - Customise music 

## 24/07/2024

BegainPaint()      ----->  EndPaint()
GetDC()            ----->  ReleaseDC()
GetWindowDC*()     ----->  ReleaseDC()
CreateDC()          ---->  DeleteDC()
CreateCompatiableDC() -->  DeleteDC()

## 26/07/2024
```python
Rectangle(left,top,right,bottom)


left-> x upper left corner
top -> y upper left corner
right -> x lower right corner
bottom -> y lower right corner

(left,top) -------
           |      |
           |      |
           --------(right,bottom)

```

## 29/07/2024

#### Multi threading

1. threads are part of same program
2. (According to point 1) All thread shares the virtual memory.
3. As we know any process will have atleast one thread(main thread) rest all threads are called secondary threads(child/decendends threads), all threads share files or global resorces.
4. each thread have independent stack.
5. Each thread has its own CPU time or quantum.
6. (Windows only) Each thread has its own separate message queue.
7. - Any thread can kill any other thread.
   - Parent thread can kill any of its child thread.
   - Os can kill any threads without indication.
8. even if point 7 is true, dont kill any thread directly, let the thread die its own natural death when its associcated function ends.
9. Sibiling threads dont share anything with each other, to make them share we have to use (TLS) thread local storage.
10. Every thread is a separate independent entity.

#### Rules
1. Thread must have specifc  return value os specific.
2. Thread must have specifc type and number of parematers value os specific.
3. you never call threads OS calls threads.
4. you can only register thread.

## 31/07/2024

#### Functions

1. _beagainthread()
2. _endthread()
3. TerminateThread(handle to thread which needs to be terminated,DWORD exit code for that code )) -> will kill other thread like murder
4. ExitThread(DWORD exit code) -> sucide of thread due to some reason
5. GetExitCodeThread() 
6. SuspendThread()
7. ResumeThread()
8. Sleep( time in milliseconds)

```
            TerminateThread()
Thread A <--------------------->Thread B
|  ^                             |   ^
|__|                             |___|

ExitThread()                    ExitThread()

```
9. CreateProcess() ->like Fork + exec in unix
10. CreateThread() ->like Fork in unix
11. GetProrityClass() -> for process
12. GetProrityClass() -> for process
    - REALTIME_PRORITY_CLASS
    - HIGH_PRIORITY_CLASS
    - ABOVE_NORMAL_PRORITY_CLASS 
    - NORMAL_PRORITY_CLASS 
    - BELOW_NORMAL_PRORITY_CLASS 
    - IDLE_PRIORITY_CLASS
13. GetThreadPriority() -> for thread
14. SetThreadPriority() -> for thread
    - THREAD_PRORITY_TIME_CRITICAL -> value 15
    - THREAD_PRORITY_HIGHEST       -> value 2
    - THREAD_PRORITY_ABOVE_NORMAL  -> value 1
    - THREAD_PRORITY_NORMAL        -> value 0
    - THREAD_PRORITY_BELOW_NORMAL  -> value -1
    - THREAD_PRORITY_LOWEST        -> value -2
    - THREAD_PRORITY_IDLE          -> value -15

#### Syncronization premivites

- To sync we need 5 sync object is used
1. Semaphore (3 function) 
    - Multile thread can access semaphore object with a specified limit and that specified count is called semcount.
    1. CreateSemaphore()
    2. OpenSemaphore()
    3. ReleaseSemaphore()
2. Mutex (3 function)
    - Mutual exclusion, 1 and only 1 thread can access mutex object
    - mutex is a semaphore with semcount = 1
    1. CreateMutex()
    2. OpenMutex()
    3. ReleaseMutex()
3. Critical Section (6 function)
    - Critical Section is not used by developers its done by OS only
    - LPCRITICAL_SECTION  are send to every other function but dev cannot change it.
    1. InitilizeCriticalSection()
    2. TryEnterCriticalSection()
    3. EnterCriticalSection()
    4. LeaveCriticalSection()
    5. DeleteCriticalSection()
    6. InitilizeCriticalSectionAndSpinCount()
4. Event object (5 function) 
    - Events which are sent to other threads
    1. CreateEvent()
    2. OpenEvent()
    3. SatEvent()
    4. ResetEvent()
    5. PulseEvent()
5. waitable timer (4 function)
    - Timers for waiting
    1. CreateWaitableTimer()
    2. OpenWaitableTimer()
    3. SetWaitableTimer()
    4. CancelWaitableTimer()
- Common to all (3 function)
    1. WaitForSingleObject()
    2. WaitForMultipleObject()
    3. CloseHandle()

- TLS (Thread local function) function
    1. GlobalAlloc()
    2. TlsAlloc()
    3. TlsSetValue()
    4. TlsGetValue()
    5. TlsFree()
    6. GlobalFree()

- Fiber ( smaller than thread )
    1. ConvertThreadToFibre()
    2. CreateFiber()
    3. DeleteFiber()
    4. SwitchToFiber()

- FLS (Fiber Local function) function
    1. GlobalAlloc()
    2. TlsAlloc()
    3. FlsSetValue()
    4. FlsGetValue()
    5. FlsFree()
    6. GlobalFree()